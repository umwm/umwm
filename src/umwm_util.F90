module umwm_util
!======================================================================!
!                                                                      !
! description: a module with utility functions.                        !
!                                                                      !
! contains: remap_i2mn     - remaps an (i) indexed array to (m,n)      !
!           remap_mn2i     - remaps an (m,n) indexed array to (i)      !
!           sigwaveheight  - calculates sig. wave height               !
!           meanwaveperiod - calculates mean wave period               !
!           raiseexception - raises an exception and prints a message  !
!           dealloc        - array deallocation routine                !
!                                                                      !
!======================================================================!
implicit none
!======================================================================!
contains



pure function remap_i2mn(field_i) result(field_mn)
!======================================================================+
!                                                                      !
! remaps an (i) indexed array to (m,n)                                 !
!                                                                      !
!======================================================================+
use umwm_module,only:imm,mm,nm,ii

! arguments
real,dimension(imm),intent(in) :: field_i
real,dimension(mm,nm)          :: field_mn

integer :: m,n
!=======================================================================

do n=1,nm
  do m=1,mm
    field_mn(m,n) = field_i(ii(m,n))
  end do
end do

end function remap_i2mn
!======================================================================>



pure function remap_mn2i(field_mn) result(field_i)
!======================================================================+
!                                                                      !
! remaps an (m,n) indexed array to (i)                                 !
!                                                                      !
!======================================================================+
use umwm_module,only:imm,mm,nm,ii

real,dimension(mm,nm),intent(in) :: field_mn
real,dimension(imm)              :: field_i
integer :: m,n

do n=1,nm
  do m=1,mm
    field_i(ii(m,n)) = field_mn(m,n)
  end do
end do

end function remap_mn2i
!======================================================================>



pure function sigwaveheight(i) result(swh)
!======================================================================+
!                                                                      !
! given a spatial grid index i, returns significant wave height        !
! at that location.                                                    !
!                                                                      !
!======================================================================+
use umwm_module,only:e,kdk,dth,om,pm

! arguments:
integer,intent(in) :: i

integer :: o,p
real    :: swh

!=======================================================================

swh = 0
do p=1,pm
  do o=1,om
    swh = swh+e(o,p,i)*kdk(o,i)
  end do
end do
swh = 4.*sqrt(swh*dth)

end function sigwaveheight
!======================================================================+



pure function meanwaveperiod(i) result(mwp)
!======================================================================+
!                                                                      !
! given a spatial grid index i, returns mean wave period at that       !
! location.                                                            !
!                                                                      !
!======================================================================+
use umwm_module,only:e,f,kdk,om,pm

! arguments:
integer,intent(in) :: i

integer :: o,p
real    :: m0,m2,mwp

m0 = 0
m2 = 0
do p=1,pm
  do o=1,om
    m0 = m0+e(o,p,i)*kdk(o,i)
    m2 = m2+f(o)**2*e(o,p,i)*kdk(o,i)
  end do
end do
mwp = sqrt(m0/m2)

end function meanwaveperiod
!======================================================================+



subroutine raiseexception(exceptiontype,routinename,message,flag)
!======================================================================+
!                                                                      !
! raises an exception, prints a message to stdout and sets the flag    !
! to .false. if present in argument list                               !
!                                                                      !
!======================================================================+

! arguments:
character(len=*),intent(in)    :: exceptiontype
character(len=*),intent(in)    :: routinename
character(len=*),intent(in)    :: message
logical,intent(inout),optional :: flag

!======================================================================+

if(present(flag))then
  flag = .false.
end if

write(unit=*,fmt='(a)')'umwm: '//trim(routinename)//': '  &
                               //trim(exceptiontype)//': '&
                               //trim(message)

endsubroutine raiseexception
!======================================================================+



subroutine dealloc
!======================================================================+
!                                                                      !
! deallocates umwm arrays                                              !
!                                                                      !
!======================================================================>
use umwm_module
!======================================================================>
#ifdef GEOS
#define _free_(a)     if (allocated(a)) deallocate(a)

_free_(d_2d)
_free_(dlon)
_free_(dlat)
_free_(dx_2d)
_free_(dy_2d)
_free_(ar_2d)
_free_(curv)
_free_(lat)
_free_(x)
_free_(y)
_free_(lon)
_free_(mask)
_free_(nproc_out)
_free_(fice)
_free_(sice)
_free_(dom)
_free_(f)
_free_(cth)
_free_(cth2)
_free_(sth)
_free_(th)
_free_(cth2pp)
_free_(cth_curv)
_free_(sth_curv)
_free_(ar)
_free_(cd)
_free_(d)
_free_(dx)
_free_(dy)
_free_(dwd)
_free_(dwl)
_free_(dwp)
! _free_(fcutoff)
_free_(dxn)
_free_(dxs)
_free_(dye)
_free_(dyw)
_free_(dcp0)
_free_(dcg0)
_free_(dcp)
_free_(dcg)
_free_(ht)
_free_(hts)
_free_(htw)
_free_(mss)
_free_(mwd)
_free_(mwp)
_free_(mwl)
_free_(momx)
_free_(momy)
_free_(cgmxx)
_free_(cgmxy)
_free_(cgmyy)
_free_(oneovar)
_free_(oneovdx)
_free_(oneovdy)
_free_(nu_water_)
_free_(rhoa)
_free_(rhow)
_free_(rhorat)
_free_(taux)
_free_(tauy)
_free_(taux_form)
_free_(tauy_form)
_free_(taux_skin)
_free_(tauy_skin)
_free_(taux_ocntop)
_free_(tauy_ocntop)
_free_(taux_ocnbot)
_free_(tauy_ocnbot)
_free_(taux_diag)
_free_(tauy_diag)
_free_(taux_snl)
_free_(tauy_snl)
_free_(taux1)
_free_(tauy1)
_free_(taux2)
_free_(tauy2)
_free_(taux3)
_free_(tauy3)
_free_(tailatmx)
_free_(tailatmy)
_free_(tailocnx)
_free_(tailocny)
_free_(epsx_atm)
_free_(epsy_atm)
_free_(epsx_ocn)
_free_(epsy_ocn)
_free_(uc)
_free_(vc)
_free_(ustar)
_free_(wspd)
_free_(wdir)
_free_(shelt)
_free_(physics_time_step)
_free_(bf1_renorm)
_free_(bf2_renorm)
_free_(cg0)
_free_(cp0)
_free_(cothkd)
_free_(dwn)
_free_(invcp0)
_free_(fkovg)
_free_(k)
_free_(k4)
_free_(kdk)
_free_(k3dk)
_free_(l2)
_free_(logl2overz)
_free_(oneoverk4)
_free_(sbf)
_free_(sdv)
_free_(sdt)
_free_(snl_arg)
_free_(dummy)
_free_(e)
_free_(ef)
_free_(rotl)
_free_(rotr)
_free_(sds)
_free_(snl)
_free_(ssin)

_free_(pl)
_free_(pr)
_free_(iw)
_free_(ie)
_free_(is)
_free_(in)
_free_(iiw)
_free_(iie)
_free_(iis)
_free_(iin)
_free_(ii)
_free_(mi)
_free_(ni)
_free_(i_exchange_indices)
_free_(oc)
_free_(fcutoff)
_free_(psim)
_free_(psiml2)

#undef _free_

#else
deallocate(ar_2d,d_2d,dlon,dlat,dx_2d,dy_2d)
deallocate(curv)
deallocate(gustu,gustv)
deallocate(lat,lon)
deallocate(x,y)
deallocate(rhoa_2d,rhow_2d)
deallocate(wspd_2d,wdir_2d)
deallocate(fice_2d,ficef,ficeb,fice)
deallocate(uwb,vwb,uw,vw,uwf,vwf,ucb,uc_2d,ucf,vcb,vc_2d,vcf)
deallocate(dom,f,cth,cth2,sth,th)
deallocate(cth_curv,sth_curv)
deallocate(ar,cd,d,dx,dy,dwd,dwl,dwp,fcutoff)
deallocate(dxn,dxs,dye,dyw)
deallocate(dcp0,dcg0,dcp,dcg)
deallocate(ht,mss,mwd,mwl,mwp)
deallocate(momx,momy)
deallocate(cgmxx,cgmxy,cgmyy)
deallocate(oneovar,oneovdx,oneovdy)
deallocate(psim,psiml2)
deallocate(rhoab,rhoa,rhoaf,rhowb,rhow,rhowf,rhorat)
deallocate(taux,tauy,taux_form,tauy_form,taux_skin,tauy_skin)
deallocate(taux_ocntop,tauy_ocntop,taux_ocnbot,tauy_ocnbot)
deallocate(taux_diag,tauy_diag)
deallocate(taux_snl,tauy_snl)
deallocate(taux1,tauy1,taux2,tauy2,taux3,tauy3)
deallocate(tailatmx,tailatmy)
deallocate(tailocnx,tailocny)
deallocate(epsx_atm, epsy_atm, epsx_ocn, epsy_ocn)
deallocate(uc,vc,ustar)
deallocate(wspd,wdir)
deallocate(shelt)
deallocate(physics_time_step)
deallocate(bf1_renorm,bf2_renorm)
deallocate(cg0,cp0,cothkd)
deallocate(dwn,invcp0)
deallocate(fkovg)
deallocate(k,k4,kdk,k3dk,l2,logl2overz,oneoverk4)
deallocate(sbf,sdv,sdt,snl_arg,dummy,e,ef,rotl,rotr,sds,snl,ssin,sice)
#endif
endsubroutine dealloc
!======================================================================!



pure function distance_haversine(lon1, lon2, lat1, lat2) result(distance)
!======================================================================+
!                                                                      !
! calculates shortest distance between two points on the surface       !
! of a sphere using the Haversine formula                              !                                 !
!                                                                      !
!======================================================================+
    
! arguments
real :: distance
real, intent(in) :: lon1, lon2, lat1, lat2

! local
real :: dlon, dlat

dlon = abs(lon2 - lon1)
dlat = abs(lat2 - lat1)

distance = 2 * asin( sqrt( (sin(0.5 * dlat))**2 + &
                     cos(lat1) * cos(lat2) * (sin(0.5 * dlon))**2 ) )

end function distance_haversine
!======================================================================>

end module umwm_util
